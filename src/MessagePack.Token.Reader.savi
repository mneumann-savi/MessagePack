// Comments taken from the official spec:
// https://github.com/msgpack/msgpack/blob/master/spec.md

:class MessagePack.Token.Reader
  :let _bytes Bytes
  :var _pos   USize

  :new (@_bytes)
    @_pos = 0

  :fun ref next! MessagePack.Token
    b = @_bytes.byte_at!(@_pos)
    case (

    // +--------+
    // |  0xc0  |
    // +--------+
    | b == 0xc0 |
      @_advance!(1), MessagePack.Token.nil

    // +--------+
    // |  0xc2  |
    // +--------+
    | b == 0xc2 |
      @_advance!(1), MessagePack.Token.bool(False)

    // +--------+
    // |  0xc3  |
    // +--------+
    | b == 0xc3 |
      @_advance!(1), MessagePack.Token.bool(True)

    // positive fixint stores 7-bit positive integer
    // +--------+
    // |0XXXXXXX|
    // +--------+
    | b <= U8[0b0_1111111] |
      uint = b.u64
      @_advance!(1), MessagePack.Token.uint(uint)

    // uint 8 stores a 8-bit unsigned integer
    // +--------+--------+
    // |  0xcc  |ZZZZZZZZ|
    // +--------+--------+
    | b == 0xcc |
      uint = @_bytes.read_byte!(@_pos + 1).u64
      @_advance!(2), MessagePack.Token.uint(uint)

    // uint 16 stores a 16-bit big-endian unsigned integer
    // +--------+--------+--------+
    // |  0xcd  |ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+
    | b == 0xcd |
      uint = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u64
      @_advance!(3), MessagePack.Token.uint(uint)

    // uint 32 stores a 32-bit big-endian unsigned integer
    // +--------+--------+--------+--------+--------+
    // |  0xce  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+
    | b == 0xce |
      uint = @_bytes.read_native_u32!(@_pos + 1).be_to_native.u64
      @_advance!(5), MessagePack.Token.uint(uint)

    // uint 64 stores a 64-bit big-endian unsigned integer
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xcf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xcf |
      uint = @_bytes.read_native_u64!(@_pos + 1).be_to_native.u64
      @_advance!(9), MessagePack.Token.uint(uint)

    // negative fixint stores 5-bit negative integer
    // +--------+
    // |111YYYYY|
    // +--------+
    | b >= U8[0b111_00000] && b <= U8[0b111_11111] |
      int = b.i8.i64
      @_advance!(1), MessagePack.Token.int(int)

    // int 8 stores a 8-bit signed integer
    // +--------+--------+
    // |  0xd0  |ZZZZZZZZ|
    // +--------+--------+
    | b == 0xd0 |
      int = @_bytes.read_byte!(@_pos + 1).i8.i64
      @_advance!(2), MessagePack.Token.int(int)

    // int 16 stores a 16-bit big-endian signed integer
    // +--------+--------+--------+
    // |  0xd1  |ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+
    | b == 0xd1 |
      int = @_bytes.read_native_u16!(@_pos + 1).be_to_native.i16.i64
      @_advance!(3), MessagePack.Token.int(int)

    // int 32 stores a 32-bit big-endian signed integer
    // +--------+--------+--------+--------+--------+
    // |  0xd2  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+
    | b == 0xd2 |
      int = @_bytes.read_native_u32!(@_pos + 1).be_to_native.i32.i64
      @_advance!(5), MessagePack.Token.int(int)

    // int 64 stores a 64-bit big-endian signed integer
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd3
    // |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xd3 |
      int = @_bytes.read_native_u64!(@_pos + 1).be_to_native.i64
      @_advance!(9), MessagePack.Token.int(int)

    // float 32 stores a floating point number in IEEE 754 single precision
    // floating point number format:
    // +--------+--------+--------+--------+--------+
    // |  0xca  |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|
    // +--------+--------+--------+--------+--------+
    | b == 0xca |
      float = F32.from_bits(@_bytes.read_native_u32!(@_pos + 1).be_to_native).f64!
      @_advance!(5), MessagePack.Token.float(float)

    // float 64 stores a floating point number in IEEE 754 double precision floating
    // point number format:
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xcb  |YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xcb |
      float = F64.from_bits(@_bytes.read_native_u64!(@_pos + 1).be_to_native)
      @_advance!(9), MessagePack.Token.float(float)

    // fixstr stores a byte array whose length is upto 31 bytes:
    // +--------+========+
    // |101XXXXX|  data  |
    // +--------+========+
    | b >= U8[0b101_00000] && b <= U8[0b101_11111] |
      len = b.bit_and(0b00011111).u32
      @_advance!(1), MessagePack.Token.string_ahead(len)

    // str 8 stores a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+========+
    // |  0xd9  |YYYYYYYY|  data  |
    // +--------+--------+========+
    | b == 0xd9 |
      len = @_bytes.read_byte!(@_pos + 1).u32
      @_advance!(2), MessagePack.Token.string_ahead(len)

    // str 16 stores a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
    // +--------+--------+--------+========+
    | b == 0xda |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u32
      @_advance!(3), MessagePack.Token.string_ahead(len)

    // str 32 stores a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+========+
    // |  0xdb  |AAAAAAAA|AAAAAAAA|AAAAAAAA|AAAAAAAA|  data  |
    // +--------+--------+--------+--------+--------+========+
    | b == 0xdb |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native
      @_advance!(5), MessagePack.Token.string_ahead(len)

    // bin 8 stores a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+========+
    // |  0xc4  |XXXXXXXX|  data  |
    // +--------+--------+========+
    | b == 0xc4 |
      len = @_bytes.read_byte!(@_pos + 1).u32
      @_advance!(2), MessagePack.Token.binary_ahead(len)

    // bin 16 stores a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xc5  |YYYYYYYY|YYYYYYYY|  data  |
    // +--------+--------+--------+========+
    | b == 0xc5 |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u32
      @_advance!(3), MessagePack.Token.binary_ahead(len)

    // bin 32 stores a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+========+
    // |  0xc6  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|  data  |
    // +--------+--------+--------+--------+--------+========+
    | b == 0xc6 |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native.u32
      @_advance!(5), MessagePack.Token.binary_ahead(len)

    // fixarray stores an array whose length is upto 15 elements:
    // +--------+~~~~~~~~~~~~~~~~~+
    // |1001XXXX|    N objects    |
    // +--------+~~~~~~~~~~~~~~~~~+
    | b >= U8[0b1001_0000] && b <= U8[0b1001_1111] |
      len = b.bit_and(0b0000_1111).u32
      @_advance!(1), MessagePack.Token.array_ahead(len)

    // array 16 stores an array whose length is upto (2^16)-1 elements:
    // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
    // |  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
    // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
    | b == 0xdc |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u32
      @_advance!(3), MessagePack.Token.array_ahead(len)

    // array 32 stores an array whose length is upto (2^32)-1 elements:
    // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
    // |  0xdd  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|    N objects    |
    // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
    | b == 0xdd |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native
      @_advance!(5), MessagePack.Token.array_ahead(len)

    // fixmap stores a map whose length is upto 15 elements
    // +--------+~~~~~~~~~~~~~~~~~+
    // |1000XXXX|   N*2 objects   |
    // +--------+~~~~~~~~~~~~~~~~~+
    | b >= U8[0b1000_0000] && b <= U8[0b1000_1111] |
      len = b.bit_and(0b0000_1111).u32
      @_advance!(1), MessagePack.Token.map_ahead(len)

    // map 16 stores a map whose length is upto (2^16)-1 elements
    // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
    // |  0xde  |YYYYYYYY|YYYYYYYY|   N*2 objects   |
    // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
    | b == 0xde |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u32
      @_advance!(3), MessagePack.Token.map_ahead(len)

    // map 32 stores a map whose length is upto (2^32)-1 elements
    // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
    // |  0xdf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|   N*2 objects   |
    // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
    | b == 0xdf |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native
      @_advance!(5), MessagePack.Token.map_ahead(len)

    // fixext 1 stores an integer and a byte array whose length is 1 byte
    // +--------+--------+--------+
    // |  0xd4  |  type  |  data  |
    // +--------+--------+--------+
    | b == 0xd4 |
      type = @_bytes.read_byte!(@_pos + 1).i8
      @_advance!(2), MessagePack.Token.ext_ahead(type, 1)

    // fixext 2 stores an integer and a byte array whose length is 2 bytes
    // +--------+--------+--------+--------+
    // |  0xd5  |  type  |       data      |
    // +--------+--------+--------+--------+
    | b == 0xd5 |
      type = @_bytes.read_byte!(@_pos + 1).i8
      @_advance!(2), MessagePack.Token.ext_ahead(type, 2)

    // fixext 4 stores an integer and a byte array whose length is 4 bytes
    // +--------+--------+--------+--------+--------+--------+
    // |  0xd6  |  type  |                data               |
    // +--------+--------+--------+--------+--------+--------+
    | b == 0xd6 |
      type = @_bytes.read_byte!(@_pos + 1).i8
      @_advance!(2), MessagePack.Token.ext_ahead(type, 4)

    // fixext 8 stores an integer and a byte array whose length is 8 bytes
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd7  |  type  |                                  data                                 |
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xd7 |
      type = @_bytes.read_byte!(@_pos + 1).i8
      @_advance!(2), MessagePack.Token.ext_ahead(type, 8)

    // fixext 16 stores an integer and a byte array whose length is 16 bytes
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd8  |  type  |                                  data                                ..
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // +--------+--------+--------+--------+--------+--------+--------+--------+
    // ..                            data (cont.)                              |
    // +--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xd8 |
      type = @_bytes.read_byte!(@_pos + 1).i8
      @_advance!(2), MessagePack.Token.ext_ahead(type, 16)

    // ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xc7  |XXXXXXXX|  type  |  data  |
    // +--------+--------+--------+========+
    | b == 0xc7 |
      len = @_bytes.read_byte!(@_pos + 1).u32
      type = @_bytes.read_byte!(@_pos + 2).i8
      @_advance!(3), MessagePack.Token.ext_ahead(type, len)

    // ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+--------+========+
    // |  0xc8  |YYYYYYYY|YYYYYYYY|  type  |  data  |
    // +--------+--------+--------+--------+========+
    | b == 0xc8 |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u32
      type = @_bytes.read_byte!(@_pos + 3).i8
      @_advance!(4), MessagePack.Token.ext_ahead(type, len)

    // ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+--------+========+
    // |  0xc9  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|  type  |  data  |
    // +--------+--------+--------+--------+--------+--------+========+
    | b == 0xc9 |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native
      type = @_bytes.read_byte!(@_pos + 5).i8
      @_advance!(6), MessagePack.Token.ext_ahead(type, len)

    | error!
    )

  :fun box is_exhausted: @_pos >= @_bytes.size

  :fun ref _advance!(n USize)
    newpos = @_pos +! n
    if (newpos <= @_bytes.size) (@_pos = newpos | error!)

  :fun ref read_string!(len U32) String
    --@read_bytes!(len).as_string

  :fun ref read_native_u32! U32
    u32 = @_bytes.read_native_u32!(@_pos)
    @_advance!(4), u32

  :fun ref read_native_u64! U64
    u64 = @_bytes.read_native_u64!(@_pos)
    @_advance!(8), u64

  :fun ref read_bytes!(len U32) Bytes
    endpos = @_pos +! len.usize
    if (endpos <= @_bytes.size) (
      bytes = @_bytes.slice(@_pos, endpos)
      @_advance!(len.usize)
      --bytes
    |
      error!  // needs more data
    )

