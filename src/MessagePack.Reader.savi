:class MessagePack.Reader
  :let _bytes Bytes
  :var _pos   USize

  :new (@_bytes)
    @_pos = 0

  :fun box is_eos: @_bytes.size >= @_pos

  :fun box peek_type!
    b = @_peek_byte!
    case (
    | b == 0xc0 | MessagePack.Type.Nil
    |             error!
    )

  :fun ref read_nil! None
    b = @_peek_byte!
    case (
    | b == 0xc0 | @_advance!, None
    |             error!
    )

  :fun ref read_bool! Bool
    b = @_peek_byte!
    case (
    | b == 0xc2 | @_advance!, False
    | b == 0xc3 | @_advance!, True
    |             error!
    )

  :fun ref read_uint! U64
    try (@_read_unsigned! |
      try (@_read_signed!.u64! | @_read_float!.u64!)
    )

  :fun ref read_int! I64
    try (@_read_signed! |
      try (@_read_unsigned!.i64! | @_read_float!.i64!)
    )

  :fun ref read_f64! F64
    try (@_read_float! |
      try (@_read_unsigned!.f64! | @_read_signed!.f64!)
    )

  :fun ref _read_unsigned! U64
    b = @_peek_byte!
    case (
    // positive fixint stores 7-bit positive integer
    // +--------+
    // |0XXXXXXX|
    // +--------+
    | b <= U8[0b0111_1111] |
      @_advance!, b.u64

    // uint 8 stores a 8-bit unsigned integer
    // +--------+--------+
    // |  0xcc  |ZZZZZZZZ|
    // +--------+--------+
    | b == 0xcc |
      num = @_bytes.read_byte!(@_pos + 1).u64
      @_advance!(2), num

    // uint 16 stores a 16-bit big-endian unsigned integer
    // +--------+--------+--------+
    // |  0xcd  |ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+
    | b == 0xcd |
      num = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u64
      @_advance!(3), num

    // uint 32 stores a 32-bit big-endian unsigned integer
    // +--------+--------+--------+--------+--------+
    // |  0xce  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+
    | b == 0xce |
      num = @_bytes.read_native_u32!(@_pos + 1).be_to_native.u64
      @_advance!(5), num

    // uint 64 stores a 64-bit big-endian unsigned integer
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xcf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xcf |
      num = @_bytes.read_native_u64!(@_pos + 1).be_to_native.u64
      @_advance!(9), num

    | error!
    )

  :fun ref _read_signed! I64
    b = @_peek_byte!
    case (
    // negative fixint stores 5-bit negative integer
    // +--------+
    // |111YYYYY|
    // +--------+
    | b >= U8[0b1110_0000] |
      @_advance!, b.i8.i64

    // int 8 stores a 8-bit signed integer
    // +--------+--------+
    // |  0xd0  |ZZZZZZZZ|
    // +--------+--------+
    | b == 0xd0 |
      num = @_bytes.read_byte!(@_pos + 1).i8.i64
      @_advance!(2), num

    // int 16 stores a 16-bit big-endian signed integer
    // +--------+--------+--------+
    // |  0xd1  |ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+
    | b == 0xd1 |
      num = @_bytes.read_native_u16!(@_pos + 1).be_to_native.i16.i64
      @_advance!(3), num

    // int 32 stores a 32-bit big-endian signed integer
    // +--------+--------+--------+--------+--------+
    // |  0xd2  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+
    | b == 0xd2 |
      num = @_bytes.read_native_u32!(@_pos + 1).be_to_native.i32.i64
      @_advance!(5), num

    // int 64 stores a 64-bit big-endian signed integer
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd3
    // |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xd3 |
      num = @_bytes.read_native_u64!(@_pos + 1).be_to_native.i64
      @_advance!(9), num

    | error!
    )

  :fun ref _read_float! F64
    case @_peek_byte! == (
    // float 32 stores a floating point number in IEEE 754 single precision
    // floating point number format:
    // +--------+--------+--------+--------+--------+
    // |  0xca  |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|
    // +--------+--------+--------+--------+--------+
    | 0xca |
      num = F32.from_bits(@_bytes.read_native_u32!(@_pos + 1).be_to_native).f64!
      @_advance!(5), num

    // float 64 stores a floating point number in IEEE 754 double precision floating
    // point number format:
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xcb  |YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | 0xca |
      num = F64.from_bits(@_bytes.read_native_u64!(@_pos + 1).be_to_native)
      @_advance!(9), num

    | error!
    )

  :fun ref read_string! String
    b = @_peek_byte!
    len USize = 0
    off USize = 0

    case (
    // fixstr stores a byte array whose length is upto 31 bytes:
    // +--------+========+
    // |101XXXXX|  data  |
    // +--------+========+
    | b >= U8[0b10100000] |
      len = b.bit_and(0b00011111).usize, off = 1

    // str 8 stores a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+========+
    // |  0xd9  |YYYYYYYY|  data  |
    // +--------+--------+========+
    | b == 0xd9 |
      len = @_bytes.read_byte!(@_pos + 1).usize, off = 2

    // str 16 stores a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
    // +--------+--------+--------+========+
    | b == 0xda |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize, off = 3

    // str 32 stores a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+========+
    // |  0xdb  |AAAAAAAA|AAAAAAAA|AAAAAAAA|AAAAAAAA|  data  |
    // +--------+--------+--------+--------+--------+========+
    | b == 0xdd |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native.usize, off = 5
    |
      error!
    )

    if (@_remaining_len >= off +! len) (
      str = @_bytes.slice(@_pos + off, @_pos + off + len).as_string
      @_advance!(off + len)
      str
    |
      error!  // needs more data
    )


  :fun ref read_binary! Bytes
    b = @_peek_byte!
    len USize = 0
    off USize = 0

    case (
    // bin 8 stores a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+========+
    // |  0xc4  |XXXXXXXX|  data  |
    // +--------+--------+========+
    | b == 0xc4 |
      len = @_bytes.read_byte!(@_pos + 1).usize, off = 2

    // bin 16 stores a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xc5  |YYYYYYYY|YYYYYYYY|  data  |
    // +--------+--------+--------+========+
    | b == 0xc5 |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize, off = 3

    // bin 32 stores a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+========+
    // |  0xc6  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|  data  |
    // +--------+--------+--------+--------+--------+========+
    | b == 0xc6 |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native.usize, off = 5

    |
      error!
    )

    if (@_remaining_len >= off +! len) (
      bytes = @_bytes.slice(@_pos + off, @_pos + off + len)
      @_advance!(off + len)
      --bytes
    |
      error!  // needs more data
    )


  :fun ref read_array_head! USize
    error!

  :fun ref read_map_head! USize
    error!

  :fun ref read_timestamp! Pair(U64)
    error!

  :fun ref read_ext! Pair(I8, Bytes)
    error!

  :fun ref _advance!(n USize = 1)
    if (@_pos +! n <= @_bytes.size) (
      @_pos = @_pos + n
    |
      error!
    )

  :fun box _remaining_len: @_bytes.size - @_pos

  :fun box _peek_byte!: @_bytes.byte_at!(@_pos)

