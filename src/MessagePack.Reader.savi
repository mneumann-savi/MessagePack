// Comments taken from the official spec:
// https://github.com/msgpack/msgpack/blob/master/spec.md

:class MessagePack.Reader
  :let _bytes Bytes
  :var _pos   USize

  :new (@_bytes)
    @_pos = 0

  :fun box is_eos: @_bytes.size >= @_pos

  :fun ref read_nil! None
    b = @_peek_byte!
    case (
    // +--------+
    // |  0xc0  |
    // +--------+
    | b == 0xc0 |
      @_advance!, None

    | error!
    )

  :fun ref read_bool! Bool
    b = @_peek_byte!
    case (
    // +--------+
    // |  0xc2  |
    // +--------+
    | b == 0xc2 |
      @_advance!, False

    // +--------+
    // |  0xc3  |
    // +--------+
    | b == 0xc3 |
      @_advance!, True

    | error!
    )

  :fun ref read_uint! U64
    try (@_read_unsigned! |
      try (@_read_signed!.u64! | @_read_float!.u64!)
    )

  :fun ref read_int! I64
    try (@_read_signed! |
      try (@_read_unsigned!.i64! | @_read_float!.i64!)
    )

  :fun ref read_f64! F64
    try (@_read_float! |
      try (@_read_unsigned!.f64! | @_read_signed!.f64!)
    )

  :fun ref _read_unsigned! U64
    b = @_peek_byte!
    case (
    // positive fixint stores 7-bit positive integer
    // +--------+
    // |0XXXXXXX|
    // +--------+
    | b <= U8[0b0111_1111] |
      @_advance!, b.u64

    // uint 8 stores a 8-bit unsigned integer
    // +--------+--------+
    // |  0xcc  |ZZZZZZZZ|
    // +--------+--------+
    | b == 0xcc |
      num = @_bytes.read_byte!(@_pos + 1).u64
      @_advance!(2), num

    // uint 16 stores a 16-bit big-endian unsigned integer
    // +--------+--------+--------+
    // |  0xcd  |ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+
    | b == 0xcd |
      num = @_bytes.read_native_u16!(@_pos + 1).be_to_native.u64
      @_advance!(3), num

    // uint 32 stores a 32-bit big-endian unsigned integer
    // +--------+--------+--------+--------+--------+
    // |  0xce  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+
    | b == 0xce |
      num = @_bytes.read_native_u32!(@_pos + 1).be_to_native.u64
      @_advance!(5), num

    // uint 64 stores a 64-bit big-endian unsigned integer
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xcf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xcf |
      num = @_bytes.read_native_u64!(@_pos + 1).be_to_native.u64
      @_advance!(9), num

    | error!
    )

  :fun ref _read_signed! I64
    b = @_peek_byte!
    case (
    // negative fixint stores 5-bit negative integer
    // +--------+
    // |111YYYYY|
    // +--------+
    | b >= U8[0b1110_0000] |
      @_advance!, b.i8.i64

    // int 8 stores a 8-bit signed integer
    // +--------+--------+
    // |  0xd0  |ZZZZZZZZ|
    // +--------+--------+
    | b == 0xd0 |
      num = @_bytes.read_byte!(@_pos + 1).i8.i64
      @_advance!(2), num

    // int 16 stores a 16-bit big-endian signed integer
    // +--------+--------+--------+
    // |  0xd1  |ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+
    | b == 0xd1 |
      num = @_bytes.read_native_u16!(@_pos + 1).be_to_native.i16.i64
      @_advance!(3), num

    // int 32 stores a 32-bit big-endian signed integer
    // +--------+--------+--------+--------+--------+
    // |  0xd2  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+
    | b == 0xd2 |
      num = @_bytes.read_native_u32!(@_pos + 1).be_to_native.i32.i64
      @_advance!(5), num

    // int 64 stores a 64-bit big-endian signed integer
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd3
    // |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | b == 0xd3 |
      num = @_bytes.read_native_u64!(@_pos + 1).be_to_native.i64
      @_advance!(9), num

    | error!
    )

  :fun ref _read_float! F64
    case @_peek_byte! == (
    // float 32 stores a floating point number in IEEE 754 single precision
    // floating point number format:
    // +--------+--------+--------+--------+--------+
    // |  0xca  |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|
    // +--------+--------+--------+--------+--------+
    | 0xca |
      num = F32.from_bits(@_bytes.read_native_u32!(@_pos + 1).be_to_native).f64!
      @_advance!(5), num

    // float 64 stores a floating point number in IEEE 754 double precision floating
    // point number format:
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xcb  |YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|YYYYYYYY|
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | 0xca |
      num = F64.from_bits(@_bytes.read_native_u64!(@_pos + 1).be_to_native)
      @_advance!(9), num

    | error!
    )

  :fun ref read_string! String
    b = @_peek_byte!
    len USize = 0
    off USize = 0

    case (
    // fixstr stores a byte array whose length is upto 31 bytes:
    // +--------+========+
    // |101XXXXX|  data  |
    // +--------+========+
    | b >= U8[0b101_00000] && b <= U8[0b101_11111] |
      len = b.bit_and(0b00011111).usize, off = 1

    // str 8 stores a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+========+
    // |  0xd9  |YYYYYYYY|  data  |
    // +--------+--------+========+
    | b == 0xd9 |
      len = @_bytes.read_byte!(@_pos + 1).usize, off = 2

    // str 16 stores a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
    // +--------+--------+--------+========+
    | b == 0xda |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize, off = 3

    // str 32 stores a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+========+
    // |  0xdb  |AAAAAAAA|AAAAAAAA|AAAAAAAA|AAAAAAAA|  data  |
    // +--------+--------+--------+--------+--------+========+
    | b == 0xdd |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native.usize, off = 5
    |
      error!
    )

    if (@_remaining_len >= off +! len) (
      str = @_bytes.slice(@_pos + off, @_pos + off + len).as_string
      @_advance!(off + len)
      str
    |
      error!  // needs more data
    )

  :fun ref read_binary! Bytes
    b = @_peek_byte!
    len USize = 0
    off USize = 0

    case (
    // bin 8 stores a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+========+
    // |  0xc4  |XXXXXXXX|  data  |
    // +--------+--------+========+
    | b == 0xc4 |
      len = @_bytes.read_byte!(@_pos + 1).usize, off = 2

    // bin 16 stores a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xc5  |YYYYYYYY|YYYYYYYY|  data  |
    // +--------+--------+--------+========+
    | b == 0xc5 |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize, off = 3

    // bin 32 stores a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+========+
    // |  0xc6  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|  data  |
    // +--------+--------+--------+--------+--------+========+
    | b == 0xc6 |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native.usize, off = 5

    |
      error!
    )

    if (@_remaining_len >= off +! len) (
      bytes = @_bytes.slice(@_pos + off, @_pos + off + len)
      @_advance!(off + len)
      --bytes
    |
      error!  // needs more data
    )

  :fun ref read_array_head! USize
    b = @_peek_byte!

    case (
    // fixarray stores an array whose length is upto 15 elements:
    // +--------+~~~~~~~~~~~~~~~~~+
    // |1001XXXX|    N objects    |
    // +--------+~~~~~~~~~~~~~~~~~+
    | b >= U8[0b1001_0000] && b <= U8[0b1001_1111] |
      n = b.bit_and(0b0000_1111).usize
      @_advance!, n

    // array 16 stores an array whose length is upto (2^16)-1 elements:
    // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
    // |  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
    // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
    | b == 0xdc |
      n = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize
      @_advance!(3), n

      // array 32 stores an array whose length is upto (2^32)-1 elements:
      // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
      // |  0xdd  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|    N objects    |
      // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
      n = @_bytes.read_native_u32!(@_pos + 1).be_to_native.usize
      @_advance!(3), n

    | error!
    )

  :fun ref read_map_head! USize
    b = @_peek_byte!
    case (
    // fixmap stores a map whose length is upto 15 elements
    // +--------+~~~~~~~~~~~~~~~~~+
    // |1000XXXX|   N*2 objects   |
    // +--------+~~~~~~~~~~~~~~~~~+
    | b >= U8[0b1000_0000] && b <= U8[0b1000_1111] |
      n = b.bit_and(0b0000_1111).usize
      @_advance!, n

      // map 16 stores a map whose length is upto (2^16)-1 elements
      // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
      // |  0xde  |YYYYYYYY|YYYYYYYY|   N*2 objects   |
      // +--------+--------+--------+~~~~~~~~~~~~~~~~~+
      n = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize
      @_advance!(3), n


      // map 32 stores a map whose length is upto (2^32)-1 elements
      // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
      // |  0xdf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|   N*2 objects   |
      // +--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
      n = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize
      @_advance!(5), n

    | error!
    )

  :fun ref read_ext! Pair(I8, Bytes)
    b = @_peek_byte!
    len USize = 0
    off USize = 0
    type I8 = 0

    case b == (
    // fixext 1 stores an integer and a byte array whose length is 1 byte
    // +--------+--------+--------+
    // |  0xd4  |  type  |  data  |
    // +--------+--------+--------+
    | 0xd4 |
      type = @_bytes.read_byte!(@_pos + 1).i8, len = 1, off = 2

    // fixext 2 stores an integer and a byte array whose length is 2 bytes
    // +--------+--------+--------+--------+
    // |  0xd5  |  type  |       data      |
    // +--------+--------+--------+--------+
    | 0xd5 |
      type = @_bytes.read_byte!(@_pos + 1).i8, len = 2, off = 2

    // fixext 4 stores an integer and a byte array whose length is 4 bytes
    // +--------+--------+--------+--------+--------+--------+
    // |  0xd6  |  type  |                data               |
    // +--------+--------+--------+--------+--------+--------+
    | 0xd6 |
      type = @_bytes.read_byte!(@_pos + 1).i8, len = 4, off = 2

    // fixext 8 stores an integer and a byte array whose length is 8 bytes
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd7  |  type  |                                  data                                 |
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | 0xd7 |
      type = @_bytes.read_byte!(@_pos + 1).i8, len = 8, off = 2

    // fixext 16 stores an integer and a byte array whose length is 16 bytes
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // |  0xd8  |  type  |                                  data                                ..
    // +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    // +--------+--------+--------+--------+--------+--------+--------+--------+
    // ..                            data (cont.)                              |
    // +--------+--------+--------+--------+--------+--------+--------+--------+
    | 0xd8 |
      type = @_bytes.read_byte!(@_pos + 1).i8, len = 16, off = 2

    // ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes:
    // +--------+--------+--------+========+
    // |  0xc7  |XXXXXXXX|  type  |  data  |
    // +--------+--------+--------+========+
    | 0xc7 |
      len = @_bytes.read_byte!(@_pos + 1).usize
      type = @_bytes.read_byte!(@_pos + 2).i8
      off = 3

    // ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes:
    // +--------+--------+--------+--------+========+
    // |  0xc8  |YYYYYYYY|YYYYYYYY|  type  |  data  |
    // +--------+--------+--------+--------+========+
    | 0xc8 |
      len = @_bytes.read_native_u16!(@_pos + 1).be_to_native.usize
      type = @_bytes.read_byte!(@_pos + 3).i8
      off = 4

    // ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes:
    // +--------+--------+--------+--------+--------+--------+========+
    // |  0xc9  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|  type  |  data  |
    // +--------+--------+--------+--------+--------+--------+========+
    | 0xc9 |
      len = @_bytes.read_native_u32!(@_pos + 1).be_to_native.usize
      type = @_bytes.read_byte!(@_pos + 5).i8
      off = 6

    | error!
    )

    if (@_remaining_len >= off +! len) (
      bytes = @_bytes.slice(@_pos + off, @_pos + off + len)
      @_advance!(off + len)
      Pair(I8, Bytes).new(type, --bytes)
    |
      error!  // needs more data
    )

  :fun ref read_timestamp! Pair(I64, U64)
    b = @_peek_byte!

    case b == (
    // timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC
    // in an 32-bit unsigned integer:
    // +--------+--------+--------+--------+--------+--------+
    // |  0xd6  |   -1   |   seconds in 32-bit unsigned int  |
    // +--------+--------+--------+--------+--------+--------+
    | 0xd6 |
      if (@_bytes.read_byte!(@_pos + 1).i8 != -1) error!
      secs = @_bytes.read_native_u32!(@_pos + 2).be_to_native.i64
      @_advance!(6)
      Pair(I64, U64).new(secs, 0)

    // timestamp 64 stores the number of seconds and nanoseconds that have elapsed since
    // 1970-01-01 00:00:00 UTC in 32-bit unsigned integers:
    // +--------+--------+--------+--------+--------+------|-+--------+--------+--------+--------+
    // |  0xd7  |   -1   | nanosec. in 30-bit unsigned int |   seconds in 34-bit unsigned int    |
    // +--------+--------+--------+--------+--------+------^-+--------+--------+--------+--------+
    | 0xd7 |
      if (@_bytes.read_byte!(@_pos + 1).i8 != -1) error!
      data = @_bytes.read_native_u64!(@_pos + 2).be_to_native.u64
      @_advance!(10)
      nanos = data.bit_shr(34), secs = data.bit_and(0x00000003ffffffff).i64
      Pair(I64, U64).new(secs, nanos)

    // timestamp 96 stores the number of seconds and nanoseconds that have elapsed since
    // 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer:
    // +--------+--------+--------+--------+--------+--------+--------+
    // |  0xc7  |   12   |   -1   |nanoseconds in 32-bit unsigned int |
    // +--------+--------+--------+--------+--------+--------+--------+
    // +--------+--------+--------+--------+--------+--------+--------+--------+
    //                     seconds in 64-bit signed int                        |
    // +--------+--------+--------+--------+--------+--------+--------+--------+
    | 0xc7 |
      if (@_bytes.read_byte!(@_pos + 1) != 12) error!
      if (@_bytes.read_byte!(@_pos + 2).i8 != -1) error!
      nanos = @_bytes.read_native_u32!(@_pos + 3).be_to_native.u64
      secs  = @_bytes.read_native_u64!(@_pos + 7).be_to_native.i64
      Pair(I64, U64).new(secs, nanos)

    | error!
    )

  :fun ref _advance!(n USize = 1)
    if (@_pos +! n <= @_bytes.size) (@_pos = @_pos + n | error!)

  :fun box _remaining_len: @_bytes.size - @_pos

  :fun box _peek_byte!: @_bytes.byte_at!(@_pos)

